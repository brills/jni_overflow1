\section{Related Work}


Previous work was done to analysis the security of the Linux PRNG, especially the non-blocking pool, \cite{Gutterman06} from a cryptographic point of view. It showed that given the internal state not known to the attacker, predicting the output of the non-blocking pool is as hard as reversing the SHA-1 hash function, even if there is not any entropy mixed in. We base our work on this assumption and do not want to challenge it. 

There was also work focusing on what could happen before \verb|/dev/urandom| being properly seeded and its internal state being completely unpredictable and unknown to the attacker. \cite{weakkeys12} successfully caught such a vulnerability that on some embedded devices the ssh-keygen was invoked before \verb|/dev/urandom| was ready, resulting in identical or factorable RSA private keys. Our goal is to identify a similar vulnerability, but on Android devices which are more complicated and not investigated. And our result and conclusion turns out to be different from that for embedded devices: we find that the user applications do not suffer from the low entropy issue while it is the anti-buffer overflow mechanisms, implemented in the kernel and other parts of Android framework that suffer from it.

Stack canary \cite{Cowan98} is an protecting mechanism that can detect buffer overflow on the stack and terminate the program before attacker taking control of it. It works by putting several bytes in the stack frame, right before the return address and checking if the contents are changed before the function returns. Two major types of canaries are proposed: 1) terminator canary it contains terminator characters on which the string operations stops and 2) random canary. Android platform has random canary implemented since version 4.0. As shown in section 4, we identified a vulnerability that the attacker could know the canary value of all Android apps by a malicious app or simply guess the canary with the cost not depending on the length of the canary.

ALSR was proposed and researched in some work. \cite{Shacham04} showed that on an 32-bit architecture ALSR could do little help. Our work confirms further this point: the ALSR implemented in Linux for the arm architecture provides only 8 bits of entropy for each mapped memory range and the base address could be leaked by a side channel.


